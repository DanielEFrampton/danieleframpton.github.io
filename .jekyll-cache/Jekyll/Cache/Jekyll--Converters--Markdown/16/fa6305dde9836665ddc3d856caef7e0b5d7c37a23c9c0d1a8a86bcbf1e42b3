I"∆<h1 id="all-things-auth-authentication--authorization-in-rails">All Things Auth: Authentication &amp; Authorization in Rails</h1>

<p>By <a href="https://gist.github.com/DanielEFrampton">Daniel Frampton</a>, student in the Back-End Engineering program at <a href="http://turing.io">Turing School of Software &amp; Design</a>.</p>

<h2 id="definitions">Definitions</h2>

<p>‚ÄúWhoa hey wait. Aren‚Äôt those the same things?‚Äù</p>

<p>Yeah nope. I‚Äôll give some examples from your own experience as a web user, but briefly this is what they are:</p>

<ul>
  <li>
    <p>Authentication: making sure people are who they claim to be.</p>
  </li>
  <li>
    <p>Authorization: giving different people access to different actions depending on user type.</p>
  </li>
</ul>

<h2 id="authentication">Authentication</h2>

<p>We‚Äôre all familiar with authentication from the user perspective. We login to websites every day using some kind of username and a password. What is less apparent is how that process works under the hood.</p>

<h3 id="registration--passwords">Registration &amp; Passwords</h3>

<p>In order to not create a calamity of epic proportions, or what one of my instructors calls a ‚ÄúCEM‚Äù (career-ending move), you never store passwords in your database in an unencrypted state lest an aspiring hacker were to gain access to them. (Usernames are not as great a concern because they are frequently publicly accessible anyway.) But if it‚Äôs best practice to encrypt passwords, you might ask, how do you check them against what the user enters when logging in?</p>

<p>The answer is through the use of <em>hashing functions</em>. Hashing functions run a given piece of information‚Äìusually some kind of string (i.e., text and numbers and so forth, like a password)‚Äìthrough what is called a ‚Äúone-way‚Äù algorithm to produce a long, complex string of characters called a hash. It is ‚Äúone-way‚Äù because because it is very difficult to undo the process and go from the hash back to the password. If it is a good hashing function, only the exact original piece of information can produce that particular hash. Therefore, the hash can stand in for the password.</p>

<p>When a user like yourself logs into a website, the same hashing algorithm that encrypted the password in the first place is used again to hash it and then check it against the hashed password in the database corresponding to your username. In this way, the unencrypted password is stored in memory only long enough to hash it and it‚Äôs never saved anywhere in an unencrypted state, keeping your user‚Äôs password secure and yourself free of risky liability.</p>

<p>In Rails, this is all accomplished through an encyrption gem called Bcrypt and Rail‚Äôs built-in SecurePassword library which is intended to work alongside Bcrypt. The steps to set it up are roughly as follows:</p>

<ol>
  <li>Require <code class="highlighter-rouge">bcrypt</code> in your project‚Äôs Gemfile and run <code class="highlighter-rouge">bundle install</code> and <code class="highlighter-rouge">bundle update</code>.</li>
  <li>In the model where you store user information (e.g., <code class="highlighter-rouge">User</code>) and in your registration and login forms, create text fields and validation rules for the users to input a <code class="highlighter-rouge">password</code> and optionally a <code class="highlighter-rouge">password_confirmation</code>.</li>
  <li>In the related table, create a <code class="highlighter-rouge">password_digest</code> column of the <code class="highlighter-rouge">string</code> data type.</li>
  <li>On the model, add the <code class="highlighter-rouge">use_secure_password</code> keyword. This tells Rails to expect a column beginning with a word of your choice ending with <code class="highlighter-rouge">_digest</code>, like <code class="highlighter-rouge">password_digest</code>, and to encrypt something input to a field with that word (i.e., <code class="highlighter-rouge">password</code>) and optionally one ending in <code class="highlighter-rouge">_confirmation</code> used for checking against typos (i.e., <code class="highlighter-rouge">password_confirmation</code>) and store its hashed value in <code class="highlighter-rouge">password_digest</code>.</li>
</ol>

<p>One other use of Bcrypt is necessary and it occurs during login of a previously registered user, which is described more fully below. Bcrypt and Rails provide an <code class="highlighter-rouge">.authenticate(password)</code> method to objects with the <code class="highlighter-rouge">has_secure_password</code> keyword which takes a password, hashes it, and checks it against the hashed password stored in whatever <code class="highlighter-rouge">_digest</code> column exists in the database for that model, returning true or false.</p>

<h3 id="login-and-sessions">Login and Sessions</h3>

<p>How many people can be logged in to Facebook at a given time? Amazon? How do their servers know whether you‚Äôre logged in or not at your particular computer in your particular browser? They do it by storing temporary but secure data about a particular user in a <em>session</em>, a server-controlled file that works very similarly to a cookie except it is encrypted and unalterable by users. Most web frameworks store their sessions on the server itself, but by default Rails stores its sessions on the respective clients‚Äô computers to save storage space and improve speed.</p>

<p>When a user logs into an app, a session is created</p>

<p>(creating a shared current_user method to access the user across all views)</p>

<p>(saving the user_id to session when logging in)</p>

<p>(deleting the user_id key/value pair from session when logging out)</p>

<h2 id="authorization">Authorization</h2>

<p>Unlike authentication, authorization is something we‚Äôre not likely to be as familiar with as web users; or at least, we weren‚Äôt aware of it. If you‚Äôve ever created a Facebook group or event, created an event on Evite, or opened a new channel on Slack, you‚Äôve experienced having a different level of access than other users in a web app: perhaps the ability to invite new people, change the details about a group or event, or to delete that group or event. Authorization is the process of granting such different levels of access to different groups of users.</p>

<p>(namespacing for organization of files)</p>

<p>(enums to track different roles and gain methods to check them on current_user)</p>

<p>(inherited before_action methods on namespaced controllers to restrict access to particular roles)</p>

<p>(using partials to maintain shared content across views in different namespaces)</p>

<h2 id="additional-reading">Additional Reading</h2>

<ul>
  <li><a href="https://www.theodinproject.com/courses/ruby-on-rails/lessons/sessions-cookies-and-authentication">Sessions, Cookies, and Authentication - The Odin Project</a></li>
  <li><a href="https://levelup.gitconnected.com/simple-authentication-guide-with-ruby-on-rails-16a6255f0be8">Simple Authentication Guide with Ruby on Rails</a></li>
  <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html">ActiveRecord::Enum - Rails Docs</a></li>
  <li><a href="https://3rd-edition.railstutorial.org/book/log_in_log_out">Chapter 8: Log in, log out - Ruby on Rails Tutorial, Michael Hartl</a></li>
  <li><a href="https://backend.turing.io/module2/lessons/authentication">Authentication - Turing School Backend Curriculum</a></li>
  <li><a href="https://backend.turing.io/module2/lessons/authorization">Authorization - Turing School Backend Curriculum</a></li>
</ul>
:ET